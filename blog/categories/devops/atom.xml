<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: DevOps | 電気羊の執務室]]></title>
  <link href="http://satrex.github.com/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://satrex.github.com/"/>
  <updated>2016-02-25T01:05:58+09:00</updated>
  <id>http://satrex.github.com/</id>
  <author>
    <name><![CDATA[satrex]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[仮想マシン構築自動化ツールのまとめ]]></title>
    <link href="http://satrex.github.com/blog/2014/06/25/dev_ops_tools/"/>
    <updated>2014-06-25T10:32:00+09:00</updated>
    <id>http://satrex.github.com/blog/2014/06/25/dev_ops_tools</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p>３月から、仮想マシン構築を自動化しようとして、
色々もがいてみました。
早いもので、もう３ヶ月も経つんですね。</p>

<p>当初、いろいろ疑問が多かった中で、
『情報が少ないので、とにかく触って掴もう』
というアプローチでやってきました。</p>

<p>ある程度わかってきたので、まとめていこうと思います。</p>

<h2>DevOpsツールについて</h2>

<p>仮想マシン構築の自動化など、コード化されたインフラを、
DevOpsと呼ぶようですね。</p>

<p>これをやるのに、よくおすすめされる構成が、
Vagrant+Chef+BerkshelfでVirtualBoxノードを作ろう！
ですね。</p>

<p>参考資料：
あとでまとめる</p>

<h2>Packer,Vagrant,Chef,Berkshelfの違いは？</h2>

<p>記事を読みながら、何がなんだかよく分からなかったのが、
各ツールの違いです。</p>

<p>ここでは、各ツールの違いをまとめてみます。
うまく伝わるかはわかりませんが・・・</p>

<h2>Packer:無から仮想マシンファイルを作る</h2>

<p>Packerは、OSイメージや既存の仮想マシンの『ファイル』から、
boxや仮想マシンノードの『ファイル』を作るアプリ。</p>

<ul>
<li>設定ファイル：

<ul>
<li>入力ファイル(OSのISOファイル、仮想マシンのファイル)</li>
<li>設定用jsonファイル(OS,バージョンごとに用意)</li>
</ul>
</li>
<li>実行対象：ローカルマシン、クラウドサービス</li>
<li>出力：ファイル(vagrant用boxファイル、仮想マシンのファイル)</li>
</ul>


<h2>Vagrant:仮想マシンを実行・廃棄する</h2>

<p>Vagrantは、仮想マシンのひな形（boxと呼ばれる）から、
実際に動く仮想マシン（ノードと呼ばれる）を作るアプリ。
実行した際に、マシンが動作を開始するのが特徴。</p>

<ul>
<li>設定ファイル：

<ul>
<li>boxファイル</li>
<li>Vagrantfile(各ノードの設定内容を記述)</li>
</ul>
</li>
<li>実行対象：ローカルマシン、クラウドサービス</li>
<li>出力：

<ul>
<li>実行中の仮想マシン</li>
<li>boxファイル(packageコマンドを使用したとき)</li>
</ul>
</li>
</ul>


<h2>Chef:実行中のマシンに設定を行う</h2>

<p>Chefは、実行中の仮想マシンや物理マシンに対し、
インストールや環境設定作業を自動化するアプリ。</p>

<p>Cookbookと呼ばれるパッケージを指定すると、
OSの差異をChefが吸収し、OSに適したコマンドで
プロビジョン(環境設定や、アプリのインストールなど)してくれる。</p>

<p>設定対象のマシンは、仮想マシンでも物理マシンでもOKだし、
ローカルでもリモートでもOK。</p>

<ul>
<li>設定ファイル:
  *Chefリポジトリ(kitchenとも呼ばれるファイルセット)
<pre>
kitchen(ここでは一部のみ)
  |- cookbooks(各設定内容をアプリごと、ジャンルごとにまとめておく)
  |- nodes(設定対象のノードと、そのノードにどんな設定を行うかを記述) </pre></li>
<li>実行対象：実行中のマシン</li>
<li>出力：実行中のマシンに設定が完了した状態</li>
</ul>


<h3>chef-soloとknife-solo</h3>

<p>ローカルの場合は<code>chef solo</code>、リモートの場合は<code>knife solo</code>の
コマンドで設定を行う。</p>

<h2>Berkshelf:ChefのCookbook管理を便利にする</h2>

<p>Chefを使う際、Berkshelfを併用することで、
Cookbookの管理が便利になる（RubyのGemのようなもの）</p>

<ul>
<li>設定ファイル：Berksfile</li>
<li>実行対象：Chefリポジトリ(=kitchen)</li>
<li>出力：整理済のChefリポジトリ</li>
</ul>


<h2>まとめ</h2>

<ul>
<li>Packer

<ul>
<li>仮想マシンの実行ファイルを作る</li>
<li>マシンの起動はインストール時のみ(電源OFFで終わる)</li>
<li>マシンを継続的に実行する事はできない</li>
</ul>
</li>
<li>Vagrant

<ul>
<li>仮想マシンの起動・終了などを制御する</li>
<li>必ず仮想マシンのひな形(box)が必要</li>
<li>OSインストールから実行することはできない</li>
</ul>
</li>
<li>Chef

<ul>
<li>マシンの設定を自動で行う</li>
<li>仮想マシンに限らず設定可能</li>
<li>マシンが起動している事が条件</li>
<li>マシンの起動自体を行うことはできない</li>
</ul>
</li>
</ul>


<p>流れとしては、こんな感じです。</p>

<ol>
<li>Packerで仮想マシンを生成</li>
<li>Vagrantで仮想マシンを実行</li>
<li>Chefでツールのインストール、設定など</li>
</ol>

]]></content>
  </entry>
  
</feed>
